#!/usr/bin/env node
import { mkdirSync, readFileSync, writeFileSync } from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

const scriptDir = path.dirname(fileURLToPath(import.meta.url));
const repoRoot = path.resolve(scriptDir, "../..");
const catalogPath = path.join(repoRoot, "docs", "reference", "operation-catalog.mdx");
const argsPath = path.join(repoRoot, "docs", "reference", "operation-arguments-and-examples.mdx");
const outputPath = path.join(repoRoot, "psagent", "src", "core", "operation-help.generated.ts");

function parseCatalogGroups(source) {
  const groups = [];
  const lines = source.split(/\r?\n/u);
  let current = null;

  for (const line of lines) {
    const headingMatch = line.match(/^##\s+(.+)$/u);
    if (headingMatch) {
      const heading = headingMatch[1].trim();
      if (heading === "Known behavior notes") {
        current = null;
        continue;
      }
      current = { name: heading, operations: [] };
      groups.push(current);
      continue;
    }

    if (!current) {
      continue;
    }

    const opMatch = line.match(/^- \[`([^`]+)`\]/u);
    if (!opMatch) {
      continue;
    }

    const operationName = opMatch[1];
    if (!current.operations.includes(operationName)) {
      current.operations.push(operationName);
    }
  }

  return groups;
}

function extractLineValue(source, prefix) {
  for (const line of source.split(/\r?\n/u)) {
    if (line.startsWith(prefix)) {
      return line.slice(prefix.length).trim();
    }
  }
  return null;
}

function parseBacktickTokens(line) {
  if (!line) {
    return [];
  }
  const tokens = [];
  for (const match of line.matchAll(/`([^`]+)`/gu)) {
    tokens.push(match[1]);
  }
  return tokens;
}

function parseOperationEntries(source) {
  const headingRegex = /^###\s+`([^`]+)`\s*$/gmu;
  const headings = [...source.matchAll(headingRegex)];
  const entries = [];

  for (let index = 0; index < headings.length; index += 1) {
    const match = headings[index];
    const name = match[1];
    const sectionStart = (match.index ?? 0) + match[0].length;
    const sectionEnd = index + 1 < headings.length ? (headings[index + 1].index ?? source.length) : source.length;
    const section = source.slice(sectionStart, sectionEnd);
    const aliases = parseBacktickTokens(extractLineValue(section, "- Aliases: "));
    const required = extractLineValue(section, "- Required: ") ?? "None";
    const supportedArgs = extractLineValue(section, "- Supported args: ") ?? "No op-specific args";
    const exampleMatch = section.match(/```json\s*([\s\S]*?)```/u);

    entries.push({
      name,
      aliases,
      required,
      supportedArgs,
      example: exampleMatch ? exampleMatch[1].trim() : ""
    });
  }

  return entries;
}

const catalogSource = readFileSync(catalogPath, "utf8");
const argsSource = readFileSync(argsPath, "utf8");

const groups = parseCatalogGroups(catalogSource);
const entries = parseOperationEntries(argsSource);

if (groups.length === 0 || entries.length === 0) {
  console.error("Failed to parse operation help docs into generated metadata.");
  process.exit(1);
}

const nextSource = `// Auto-generated by scripts/build/generate-operation-help.mjs. Do not edit manually.
export const GENERATED_OPERATION_CATALOG = ${JSON.stringify(groups, null, 2)} as const;

export const GENERATED_OPERATION_ENTRIES = ${JSON.stringify(entries, null, 2)} as const;
`;

let currentSource = "";
try {
  currentSource = readFileSync(outputPath, "utf8");
} catch {
  // First run or missing file.
}

if (currentSource !== nextSource) {
  mkdirSync(path.dirname(outputPath), { recursive: true });
  writeFileSync(outputPath, nextSource, "utf8");
  console.log(`Synced operation help metadata (${groups.length} groups, ${entries.length} entries)`);
}
