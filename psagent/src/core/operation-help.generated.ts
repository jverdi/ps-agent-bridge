// Auto-generated by scripts/build/generate-operation-help.mjs. Do not edit manually.
export const GENERATED_OPERATION_CATALOG = [
  {
    "name": "Documents",
    "operations": [
      "createDocument",
      "openDocument",
      "duplicateDocument",
      "saveDocument",
      "saveDocumentAs",
      "closeDocument",
      "resizeImage",
      "resizeCanvas",
      "cropDocument",
      "trimDocument",
      "rotateDocument",
      "changeDocumentMode",
      "convertColorProfile",
      "calculations",
      "applyImage",
      "splitChannels",
      "sampleColor",
      "createHistorySnapshot",
      "listHistoryStates",
      "restoreHistoryState",
      "suspendHistory",
      "flattenDocument",
      "mergeVisible"
    ]
  },
  {
    "name": "Layers and grouping",
    "operations": [
      "createLayer",
      "createPixelLayer",
      "createGroup",
      "groupLayers",
      "ungroupLayer",
      "deleteLayer",
      "renameLayer",
      "duplicateLayer",
      "selectLayer",
      "selectLayers",
      "moveLayer",
      "setLayerVisibility",
      "showLayer",
      "hideLayer",
      "setLayerOpacity",
      "setBlendMode",
      "setLayerProps",
      "setLayerEffects",
      "bringLayerToFront",
      "sendLayerToBack",
      "mergeLayer",
      "createArtboard",
      "resizeArtboard",
      "reorderArtboards",
      "rasterizeLayer",
      "linkLayers",
      "unlinkLayer",
      "createLayerComp",
      "applyLayerComp",
      "recaptureLayerComp",
      "deleteLayerComp"
    ]
  },
  {
    "name": "Transform and layout",
    "operations": [
      "transformLayer",
      "alignLayers",
      "distributeLayers",
      "autoAlignLayers",
      "autoBlendLayers",
      "translateLayer",
      "scaleLayer",
      "rotateLayer",
      "flipLayer",
      "skewLayer"
    ]
  },
  {
    "name": "Assets and smart objects",
    "operations": [
      "placeAsset",
      "convertToSmartObject",
      "replaceSmartObject",
      "relinkSmartObject",
      "editSmartObject"
    ]
  },
  {
    "name": "Selection and masks",
    "operations": [
      "selectAll",
      "deselect",
      "inverseSelection",
      "featherSelection",
      "expandSelection",
      "contractSelection",
      "growSelection",
      "smoothSelection",
      "selectSubject",
      "selectColorRange",
      "refineSelection",
      "selectRectangle",
      "selectEllipse",
      "selectPolygon",
      "selectLayerPixels",
      "createChannel",
      "duplicateChannel",
      "deleteChannel",
      "saveSelection",
      "saveSelectionTo",
      "loadSelection",
      "createPath",
      "createPathFromPoints",
      "setPathPoints",
      "deletePath",
      "makeWorkPathFromSelection",
      "makeSelectionFromPath",
      "fillPath",
      "strokePath",
      "makeClippingPath",
      "addGuide",
      "removeGuide",
      "clearGuides",
      "setSelection",
      "modifySelection",
      "createLayerMask",
      "deleteLayerMask",
      "applyLayerMask",
      "createClippingMask",
      "releaseClippingMask",
      "createVectorMask",
      "deleteVectorMask"
    ]
  },
  {
    "name": "Text and shapes",
    "operations": [
      "createTextLayer",
      "setText",
      "setTextStyle",
      "setTextWarp",
      "setTextOnPath",
      "createShapeLayer"
    ]
  },
  {
    "name": "Adjustments and filters",
    "operations": [
      "createAdjustmentLayer",
      "setAdjustmentLayer",
      "applyFilter",
      "applyGaussianBlur",
      "applyAddNoise",
      "applyUnsharpMask",
      "applySharpen",
      "applyBlur",
      "applyMotionBlur",
      "applySmartBlur",
      "applyHighPass",
      "applyMedianNoise",
      "applyMinimum",
      "applyMaximum",
      "applyDustAndScratches",
      "contentAwareFill",
      "contentAwareScale",
      "contentAwareMove"
    ]
  },
  {
    "name": "Export and low-level actions",
    "operations": [
      "export",
      "exportDocument",
      "exportLayer",
      "exportLayersByName",
      "exportArtboards",
      "getPixels",
      "putPixels",
      "getSelectionPixels",
      "putSelectionPixels",
      "getLayerMaskPixels",
      "putLayerMaskPixels",
      "encodeImageData",
      "playAction",
      "playActionSet",
      "batchPlay"
    ]
  }
] as const;

export const GENERATED_OPERATION_ENTRIES = [
  {
    "name": "createDocument",
    "aliases": [
      "doc.create",
      "document.create",
      "newDocument"
    ],
    "required": "None",
    "supportedArgs": "`depth`, `fill`, `height`, `mode`, `name`, `preset`, `profile`, `resolution`, `width`",
    "notes": "`mode` accepts Photoshop document mode enums (`rgb`, `cmyk`, `lab`, `grayscale`, `bitmap`, `indexedColor`, `multichannel`, `duotone`). `fill` accepts enum values (`white`, `black`, `transparent`, `backgroundColor`). Aliases like `rgbColor` are normalized for compatibility. Hex color strings are not valid `fill` values.",
    "example": "{\n  \"op\": \"createDocument\",\n  \"name\": \"New Doc\",\n  \"width\": 1080,\n  \"height\": 1080,\n  \"resolution\": 72,\n  \"mode\": \"rgb\",\n  \"fill\": \"white\"\n}"
  },
  {
    "name": "openDocument",
    "aliases": [
      "doc.open",
      "document.open"
    ],
    "required": "`input (or path/source)`",
    "supportedArgs": "`input`, `path`, `source`",
    "notes": "",
    "example": "{\n  \"op\": \"openDocument\",\n  \"input\": \"./assets/source.psd\"\n}"
  },
  {
    "name": "duplicateDocument",
    "aliases": [
      "doc.duplicate",
      "document.duplicate"
    ],
    "required": "None",
    "supportedArgs": "`docRef`, `mergeLayersOnly`, `name`, `target`",
    "notes": "",
    "example": "{\n  \"op\": \"duplicateDocument\",\n  \"name\": \"Variant A\"\n}"
  },
  {
    "name": "saveDocument",
    "aliases": [
      "doc.save",
      "document.save"
    ],
    "required": "None",
    "supportedArgs": "`allowDialog`, `asCopy`, `docRef`, `options`, `output`, `quality`, `target`",
    "notes": "",
    "example": "{\n  \"op\": \"saveDocument\",\n  \"output\": \"./tmp/current.psd\"\n}"
  },
  {
    "name": "saveDocumentAs",
    "aliases": [
      "doc.saveAs",
      "document.saveAs"
    ],
    "required": "`output`",
    "supportedArgs": "`docRef`, `target`, `output`, `format`, `quality`, `asCopy`, `options`",
    "notes": "Use `output` for the destination path. `path` is not a supported key for this op.",
    "example": "{\n  \"op\": \"saveDocumentAs\",\n  \"output\": \"./tmp/output.psd\"\n}"
  },
  {
    "name": "closeDocument",
    "aliases": [
      "doc.close",
      "document.close"
    ],
    "required": "None",
    "supportedArgs": "`docRef`, `mode`, `output`, `save`, `saveChanges`, `saveOption`, `target`",
    "notes": "",
    "example": "{\n  \"op\": \"closeDocument\",\n  \"save\": false\n}"
  },
  {
    "name": "resizeImage",
    "aliases": [
      "document.resizeImage"
    ],
    "required": "`width` and/or `height`",
    "supportedArgs": "`docRef`, `height`, `resolution`, `target`, `width`",
    "notes": "",
    "example": "{\n  \"op\": \"resizeImage\",\n  \"width\": 1920,\n  \"height\": 1080,\n  \"resolution\": 72\n}"
  },
  {
    "name": "resizeCanvas",
    "aliases": [
      "document.resizeCanvas"
    ],
    "required": "`width`, `height`",
    "supportedArgs": "`anchor`, `docRef`, `height`, `target`, `width`",
    "notes": "",
    "example": "{\n  \"op\": \"resizeCanvas\",\n  \"width\": 1200,\n  \"height\": 1200,\n  \"anchor\": \"middleCenter\"\n}"
  },
  {
    "name": "cropDocument",
    "aliases": [
      "document.crop"
    ],
    "required": "`bounds {left, top, right, bottom}` (or top-level `left/top/right/bottom`)",
    "supportedArgs": "`angle`, `bounds`, `docRef`, `height`, `target`, `width`",
    "notes": "",
    "example": "{\n  \"op\": \"cropDocument\",\n  \"bounds\": {\n    \"left\": 0,\n    \"top\": 0,\n    \"right\": 1080,\n    \"bottom\": 1920\n  }\n}"
  },
  {
    "name": "trimDocument",
    "aliases": [
      "document.trim"
    ],
    "required": "None",
    "supportedArgs": "`bottom`, `docRef`, `left`, `right`, `target`, `top`, `trimType`",
    "notes": "",
    "example": "{\n  \"op\": \"trimDocument\",\n  \"trimType\": \"transparent\",\n  \"top\": true,\n  \"left\": true,\n  \"bottom\": true,\n  \"right\": true\n}"
  },
  {
    "name": "rotateDocument",
    "aliases": [
      "document.rotate"
    ],
    "required": "`angle`",
    "supportedArgs": "`anchor`, `angle`, `docRef`, `options`, `target`",
    "notes": "",
    "example": "{\n  \"op\": \"rotateDocument\",\n  \"angle\": 90\n}"
  },
  {
    "name": "changeDocumentMode",
    "aliases": [
      "document.changeMode"
    ],
    "required": "`mode (or to/newMode)`",
    "supportedArgs": "`docRef`, `mode`, `newMode`, `target`, `to`",
    "notes": "",
    "example": "{\n  \"op\": \"changeDocumentMode\",\n  \"mode\": \"grayscale\"\n}"
  },
  {
    "name": "convertColorProfile",
    "aliases": [
      "document.convertProfile"
    ],
    "required": "`profile (or name/colorProfile)`",
    "supportedArgs": "`blackPointCompensation`, `colorProfile`, `dither`, `docRef`, `intent`, `name`, `profile`, `target`",
    "notes": "",
    "example": "{\n  \"op\": \"convertColorProfile\",\n  \"profile\": \"Display P3\",\n  \"intent\": \"relativeColorimetric\",\n  \"blackPointCompensation\": true\n}"
  },
  {
    "name": "calculations",
    "aliases": [
      "document.calculations"
    ],
    "required": "None",
    "supportedArgs": "`docRef`, `options`, `target`, plus calculation option fields",
    "notes": "",
    "example": "{\n  \"op\": \"calculations\",\n  \"options\": {\n    \"result\": \"newChannel\"\n  }\n}"
  },
  {
    "name": "applyImage",
    "aliases": [
      "document.applyImage"
    ],
    "required": "None",
    "supportedArgs": "`docRef`, `options`, `target`, `targetLayer`, plus apply-image option fields",
    "notes": "",
    "example": "{\n  \"op\": \"applyImage\",\n  \"targetLayer\": {\n    \"layerName\": \"Hero\"\n  },\n  \"options\": {\n    \"blendMode\": \"multiply\",\n    \"opacity\": 65\n  }\n}"
  },
  {
    "name": "splitChannels",
    "aliases": [
      "document.splitChannels"
    ],
    "required": "None",
    "supportedArgs": "`docRef`, `target`",
    "notes": "",
    "example": "{\n  \"op\": \"splitChannels\"\n}"
  },
  {
    "name": "sampleColor",
    "aliases": [
      "document.sampleColor"
    ],
    "required": "`x/y (or position{x,y})`",
    "supportedArgs": "`docRef`, `position`, `target`, `x`, `y`",
    "notes": "",
    "example": "{\n  \"op\": \"sampleColor\",\n  \"x\": 220,\n  \"y\": 340\n}"
  },
  {
    "name": "createHistorySnapshot",
    "aliases": [
      "history.snapshot"
    ],
    "required": "None",
    "supportedArgs": "`docRef`, `name`, `snapshotName`, `target`",
    "notes": "",
    "example": "{\n  \"op\": \"createHistorySnapshot\",\n  \"name\": \"Before Retouch\"\n}"
  },
  {
    "name": "listHistoryStates",
    "aliases": [
      "history.list"
    ],
    "required": "None",
    "supportedArgs": "`docRef`, `target`",
    "notes": "",
    "example": "{\n  \"op\": \"listHistoryStates\"\n}"
  },
  {
    "name": "restoreHistoryState",
    "aliases": [
      "history.restore"
    ],
    "required": "`historyStateId/id/historyStateName/name`",
    "supportedArgs": "`docRef`, `historyStateId`, `historyStateName`, `id`, `name`, `target`",
    "notes": "",
    "example": "{\n  \"op\": \"restoreHistoryState\",\n  \"historyStateName\": \"Before Retouch\"\n}"
  },
  {
    "name": "suspendHistory",
    "aliases": [
      "history.suspend"
    ],
    "required": "`name/historyStateName`, `commands[] (or command/descriptor)`",
    "supportedArgs": "`commands`, `command`, `descriptor`, `historyStateName`, `name`, `options`",
    "notes": "Wraps descriptors in one named history state where supported by Photoshop.",
    "example": "{\n  \"op\": \"suspendHistory\",\n  \"name\": \"Batch Style Update\",\n  \"commands\": [\n    {\n      \"_obj\": \"set\",\n      \"_target\": [\n        {\n          \"_ref\": \"layer\",\n          \"_enum\": \"ordinal\",\n          \"_value\": \"targetEnum\"\n        }\n      ],\n      \"to\": {\n        \"_obj\": \"layer\",\n        \"opacity\": {\n          \"_unit\": \"percentUnit\",\n          \"_value\": 80\n        }\n      }\n    }\n  ]\n}"
  },
  {
    "name": "flattenDocument",
    "aliases": [
      "flattenImage",
      "document.flatten"
    ],
    "required": "None",
    "supportedArgs": "`docRef`, `target`",
    "notes": "",
    "example": "{\n  \"op\": \"flattenDocument\"\n}"
  },
  {
    "name": "mergeVisible",
    "aliases": [
      "mergeVisibleLayers",
      "document.mergeVisibleLayers"
    ],
    "required": "None",
    "supportedArgs": "`docRef`, `target`",
    "notes": "",
    "example": "{\n  \"op\": \"mergeVisible\"\n}"
  },
  {
    "name": "createLayer",
    "aliases": [
      "layer.create"
    ],
    "required": "None",
    "supportedArgs": "`artboard`, `at`, `blendMode`, `container`, `docRef`, `fillNeutral`, `kind`, `name`, `opacity`, `parent`, `parentIndex`, `parentLayer`, `parentPlacement`, `placement`, `targetParent`",
    "notes": "",
    "example": "{\n  \"op\": \"createLayer\",\n  \"name\": \"Foreground\"\n}"
  },
  {
    "name": "createPixelLayer",
    "aliases": [
      "layer.createPixel"
    ],
    "required": "None",
    "supportedArgs": "`artboard`, `at`, `blendMode`, `container`, `docRef`, `fillNeutral`, `kind`, `name`, `opacity`, `parent`, `parentIndex`, `parentLayer`, `parentPlacement`, `placement`, `targetParent`",
    "notes": "",
    "example": "{\n  \"op\": \"createPixelLayer\",\n  \"name\": \"Paint\"\n}"
  },
  {
    "name": "createGroup",
    "aliases": [
      "createLayerGroup",
      "layer.createGroup"
    ],
    "required": "None",
    "supportedArgs": "`artboard`, `at`, `blendMode`, `container`, `docRef`, `fromLayers`, `name`, `opacity`, `parent`, `parentIndex`, `parentLayer`, `parentPlacement`, `placement`, `targetParent`",
    "notes": "",
    "example": "{\n  \"op\": \"createGroup\",\n  \"name\": \"Hero Group\"\n}"
  },
  {
    "name": "groupLayers",
    "aliases": [
      "layer.group"
    ],
    "required": "`targets[]`",
    "supportedArgs": "`docRef`, `name`, `targets`",
    "notes": "",
    "example": "{\n  \"op\": \"groupLayers\",\n  \"targets\": [\n    {\n      \"layerName\": \"Title\"\n    },\n    {\n      \"layerName\": \"CTA\"\n    }\n  ],\n  \"name\": \"Header Group\"\n}"
  },
  {
    "name": "ungroupLayer",
    "aliases": [
      "layer.ungroup"
    ],
    "required": "None",
    "supportedArgs": "No op-specific args",
    "notes": "",
    "example": "{\n  \"op\": \"ungroupLayer\",\n  \"target\": {\n    \"layerName\": \"Header Group\"\n  }\n}"
  },
  {
    "name": "deleteLayer",
    "aliases": [
      "layer.delete"
    ],
    "required": "`target (or active layer)`",
    "supportedArgs": "No op-specific args",
    "notes": "",
    "example": "{\n  \"op\": \"deleteLayer\",\n  \"target\": {\n    \"layerName\": \"Scratch\"\n  }\n}"
  },
  {
    "name": "renameLayer",
    "aliases": [
      "layer.rename"
    ],
    "required": "`target (or active layer)`, `name (or newName)`",
    "supportedArgs": "`name`",
    "notes": "",
    "example": "{\n  \"op\": \"renameLayer\",\n  \"target\": {\n    \"layerName\": \"Layer 1\"\n  },\n  \"name\": \"Hero\"\n}"
  },
  {
    "name": "duplicateLayer",
    "aliases": [
      "layer.duplicate"
    ],
    "required": "`target (or active layer)`",
    "supportedArgs": "`insertionLocation`, `name`, `placement`, `relativeTo`",
    "notes": "",
    "example": "{\n  \"op\": \"duplicateLayer\",\n  \"target\": {\n    \"layerName\": \"Hero\"\n  },\n  \"name\": \"Hero Copy\"\n}"
  },
  {
    "name": "selectLayer",
    "aliases": [
      "layer.select"
    ],
    "required": "`target (or active layer)`",
    "supportedArgs": "No op-specific args",
    "notes": "",
    "example": "{\n  \"op\": \"selectLayer\",\n  \"target\": {\n    \"layerName\": \"Hero\"\n  }\n}"
  },
  {
    "name": "selectLayers",
    "aliases": [
      "layer.selectMany"
    ],
    "required": "`targets[]`",
    "supportedArgs": "`targets`",
    "notes": "",
    "example": "{\n  \"op\": \"selectLayers\",\n  \"targets\": [\n    {\n      \"layerName\": \"Hero\"\n    },\n    {\n      \"layerName\": \"CTA\"\n    }\n  ],\n  \"mode\": \"set\"\n}"
  },
  {
    "name": "moveLayer",
    "aliases": [
      "layer.move",
      "reorderLayer",
      "layer.reorder"
    ],
    "required": "`target (or active layer)`, `one of: by{x,y}, relativeTo+placement, to(front/back), or index/at`",
    "supportedArgs": "`at`, `by`, `index`, `insertLocation`, `placement`, `relativeTo`, `to`",
    "notes": "",
    "example": "{\n  \"op\": \"moveLayer\",\n  \"target\": {\n    \"layerName\": \"CTA\"\n  },\n  \"relativeTo\": {\n    \"layerName\": \"Hero\"\n  },\n  \"placement\": \"placeAfter\"\n}"
  },
  {
    "name": "setLayerVisibility",
    "aliases": [
      "layer.visibility"
    ],
    "required": "`target (or active layer)`, `visible`",
    "supportedArgs": "`visible`",
    "notes": "",
    "example": "{\n  \"op\": \"setLayerVisibility\",\n  \"target\": {\n    \"layerName\": \"CTA\"\n  },\n  \"visible\": true\n}"
  },
  {
    "name": "showLayer",
    "aliases": [
      "layer.show"
    ],
    "required": "`target (or active layer)`",
    "supportedArgs": "No op-specific args",
    "notes": "",
    "example": "{\n  \"op\": \"showLayer\",\n  \"target\": {\n    \"layerName\": \"CTA\"\n  }\n}"
  },
  {
    "name": "hideLayer",
    "aliases": [
      "layer.hide"
    ],
    "required": "`target (or active layer)`",
    "supportedArgs": "No op-specific args",
    "notes": "",
    "example": "{\n  \"op\": \"hideLayer\",\n  \"target\": {\n    \"layerName\": \"CTA\"\n  }\n}"
  },
  {
    "name": "setLayerOpacity",
    "aliases": [
      "layer.opacity"
    ],
    "required": "`target (or active layer)`, `opacity`",
    "supportedArgs": "`opacity`",
    "notes": "",
    "example": "{\n  \"op\": \"setLayerOpacity\",\n  \"target\": {\n    \"layerName\": \"Hero\"\n  },\n  \"opacity\": 80\n}"
  },
  {
    "name": "setBlendMode",
    "aliases": [
      "layer.blendMode"
    ],
    "required": "`target (or active layer)`, `blendMode`",
    "supportedArgs": "`blendMode`",
    "notes": "",
    "example": "{\n  \"op\": \"setBlendMode\",\n  \"target\": {\n    \"layerName\": \"Texture\"\n  },\n  \"blendMode\": \"multiply\"\n}"
  },
  {
    "name": "setLayerProps",
    "aliases": [
      "layer.setProps"
    ],
    "required": "`target (or active layer)`",
    "supportedArgs": "`blendMode`, `locked`, `opacity`, `visible`",
    "notes": "",
    "example": "{\n  \"op\": \"setLayerProps\",\n  \"target\": {\n    \"layerName\": \"Hero\"\n  },\n  \"visible\": true,\n  \"opacity\": 90,\n  \"blendMode\": \"normal\"\n}"
  },
  {
    "name": "setLayerEffects",
    "aliases": [
      "layer.effects"
    ],
    "required": "`target (or active layer)` plus one of `effects`, effect fields, or `clear: true`",
    "supportedArgs": "`bevelEmboss`, `clear`, `colorOverlay`, `dropShadow`, `effects`, `gradientOverlay`, `innerGlow`, `innerShadow`, `outerGlow`, `satin`, `scale`, `stroke`",
    "notes": "",
    "example": "{\n  \"op\": \"setLayerEffects\",\n  \"target\": {\n    \"layerName\": \"Headline\"\n  },\n  \"dropShadow\": {\n    \"color\": \"#000000\",\n    \"opacity\": 45,\n    \"angle\": 120,\n    \"distance\": 10,\n    \"size\": 18\n  },\n  \"stroke\": {\n    \"color\": \"#ffffff\",\n    \"size\": 2,\n    \"position\": \"outside\",\n    \"opacity\": 100\n  }\n}"
  },
  {
    "name": "bringLayerToFront",
    "aliases": [
      "layer.bringToFront"
    ],
    "required": "`target (or active layer)`",
    "supportedArgs": "No op-specific args",
    "notes": "",
    "example": "{\n  \"op\": \"bringLayerToFront\",\n  \"target\": {\n    \"layerName\": \"CTA\"\n  }\n}"
  },
  {
    "name": "sendLayerToBack",
    "aliases": [
      "layer.sendToBack"
    ],
    "required": "`target (or active layer)`",
    "supportedArgs": "No op-specific args",
    "notes": "",
    "example": "{\n  \"op\": \"sendLayerToBack\",\n  \"target\": {\n    \"layerName\": \"Background\"\n  }\n}"
  },
  {
    "name": "mergeLayer",
    "aliases": [
      "mergeLayers",
      "layer.merge"
    ],
    "required": "`target (or active layer)`",
    "supportedArgs": "`name`, `targets`",
    "notes": "",
    "example": "{\n  \"op\": \"mergeLayer\",\n  \"target\": {\n    \"layerName\": \"Overlay\"\n  }\n}"
  },
  {
    "name": "rasterizeLayer",
    "aliases": [
      "layer.rasterize"
    ],
    "required": "`target (or active layer)`",
    "supportedArgs": "`rasterizeType`, `targetType`",
    "notes": "",
    "example": "{\n  \"op\": \"rasterizeLayer\",\n  \"target\": {\n    \"layerName\": \"Smart Object\"\n  }\n}"
  },
  {
    "name": "linkLayers",
    "aliases": [
      "layer.link"
    ],
    "required": "`targets[]`",
    "supportedArgs": "`targets`",
    "notes": "",
    "example": "{\n  \"op\": \"linkLayers\",\n  \"targets\": [\n    {\n      \"layerName\": \"Icon\"\n    },\n    {\n      \"layerName\": \"Label\"\n    }\n  ]\n}"
  },
  {
    "name": "unlinkLayer",
    "aliases": [
      "layer.unlink"
    ],
    "required": "`target (or active layer)`",
    "supportedArgs": "No op-specific args",
    "notes": "",
    "example": "{\n  \"op\": \"unlinkLayer\",\n  \"target\": {\n    \"layerName\": \"Icon\"\n  }\n}"
  },
  {
    "name": "createLayerComp",
    "aliases": [
      "layerComp.create"
    ],
    "required": "None",
    "supportedArgs": "`captureAppearance`, `capturePosition`, `captureVisibility`, `comment`, `docRef`, `name`",
    "notes": "",
    "example": "{\n  \"op\": \"createLayerComp\",\n  \"name\": \"Hero Variant\",\n  \"comment\": \"Primary hero layout\"\n}"
  },
  {
    "name": "applyLayerComp",
    "aliases": [
      "layerComp.apply"
    ],
    "required": "`layerComp target (name/id)`",
    "supportedArgs": "`docRef`, `layerComp`, `layerCompId`, `layerCompName`, `name`, `target`",
    "notes": "",
    "example": "{\n  \"op\": \"applyLayerComp\",\n  \"layerComp\": \"Hero Variant\"\n}"
  },
  {
    "name": "recaptureLayerComp",
    "aliases": [
      "layerComp.recapture"
    ],
    "required": "`layerComp target (name/id)`",
    "supportedArgs": "`captureAppearance`, `capturePosition`, `captureVisibility`, `childLayerCompState`, `docRef`, `layerComp`, `layerCompId`, `layerCompName`, `name`, `target`",
    "notes": "",
    "example": "{\n  \"op\": \"recaptureLayerComp\",\n  \"layerComp\": \"Hero Variant\",\n  \"captureVisibility\": true\n}"
  },
  {
    "name": "deleteLayerComp",
    "aliases": [
      "layerComp.delete",
      "layerComp.remove"
    ],
    "required": "`layerComp target (name/id)`",
    "supportedArgs": "`docRef`, `layerComp`, `layerCompId`, `layerCompName`, `name`, `target`",
    "notes": "",
    "example": "{\n  \"op\": \"deleteLayerComp\",\n  \"layerComp\": \"Hero Variant\"\n}"
  },
  {
    "name": "createArtboard",
    "aliases": [
      "artboard.create"
    ],
    "required": "None",
    "supportedArgs": "`bounds`, `docRef`, `frame`, `height`, `name`, `rect`, `target`, `width`, `x`, `y`",
    "notes": "If no bounds/frame/rect are supplied, the current document bounds are used.",
    "example": "{\n  \"op\": \"createArtboard\",\n  \"name\": \"Mobile\",\n  \"x\": 0,\n  \"y\": 0,\n  \"width\": 1080,\n  \"height\": 1920\n}"
  },
  {
    "name": "resizeArtboard",
    "aliases": [
      "artboard.resize"
    ],
    "required": "`target/artboard`, plus `bounds/frame/rect` or `x,y,width,height`",
    "supportedArgs": "`artboard`, `artboardId`, `artboardName`, `bounds`, `frame`, `height`, `rect`, `target`, `width`, `x`, `y`",
    "notes": "",
    "example": "{\n  \"op\": \"resizeArtboard\",\n  \"target\": {\n    \"layerName\": \"Mobile\"\n  },\n  \"width\": 1200,\n  \"height\": 1920,\n  \"x\": 0,\n  \"y\": 0\n}"
  },
  {
    "name": "reorderArtboards",
    "aliases": [
      "artboard.reorder"
    ],
    "required": "`target/artboard`, plus one of `at`, `relativeTo+placement`, `to(front/back)`",
    "supportedArgs": "`artboard`, `artboardId`, `artboardName`, `at`, `index`, `placement`, `relativeTo`, `target`, `to`",
    "notes": "`by` and `parent` are not supported for artboard reordering. Both `target` and optional `relativeTo` must resolve to artboards.",
    "example": "{\n  \"op\": \"reorderArtboards\",\n  \"target\": {\n    \"layerName\": \"Mobile\"\n  },\n  \"to\": \"front\"\n}"
  },
  {
    "name": "exportArtboards",
    "aliases": [
      "artboard.export"
    ],
    "required": "`outputDir` (or `commands[]/command/descriptor`)",
    "supportedArgs": "`command`, `commands`, `descriptor`, `format`, `options`, `outputDir`",
    "notes": "Without explicit descriptors, this op exports each detected artboard to `outputDir` using per-artboard crop bounds. It errors when no artboards are present.",
    "example": "{\n  \"op\": \"exportArtboards\",\n  \"outputDir\": \"./tmp/artboards\",\n  \"format\": \"png\"\n}"
  },
  {
    "name": "transformLayer",
    "aliases": [
      "layer.transform"
    ],
    "required": "`target (or active layer)`",
    "supportedArgs": "`angle`, `angleH`, `angleV`, `axis`, `by`, `flip`, `height`, `horizontal`, `percent`, `rotate`, `scale`, `scaleX`, `scaleY`, `skewX`, `skewY`, `translate`, `vertical`, `width`, `x`, `y`",
    "notes": "For translation via `transformLayer`, pass top-level `x`/`y` (or `horizontal`/`vertical`). `translateLayer` uses the same movement fields.",
    "example": "{\n  \"op\": \"transformLayer\",\n  \"target\": {\n    \"layerName\": \"Hero\"\n  },\n  \"scaleX\": 95,\n  \"scaleY\": 95,\n  \"rotate\": 2\n}"
  },
  {
    "name": "alignLayers",
    "aliases": [
      "layer.align"
    ],
    "required": "at least 2 layers via `targets[]` or current active selection",
    "supportedArgs": "`targets`, `axis`, `type`",
    "notes": "",
    "example": "{\n  \"op\": \"alignLayers\",\n  \"axis\": \"horizontalCenter\",\n  \"targets\": [\n    {\n      \"layerName\": \"Title\"\n    },\n    {\n      \"layerName\": \"CTA\"\n    }\n  ]\n}"
  },
  {
    "name": "distributeLayers",
    "aliases": [
      "layer.distribute"
    ],
    "required": "at least 3 layers via `targets[]` or current active selection",
    "supportedArgs": "`targets`, `axis`, `type`",
    "notes": "",
    "example": "{\n  \"op\": \"distributeLayers\",\n  \"axis\": \"horizontal\",\n  \"targets\": [\n    {\n      \"layerName\": \"Card 1\"\n    },\n    {\n      \"layerName\": \"Card 2\"\n    },\n    {\n      \"layerName\": \"Card 3\"\n    }\n  ]\n}"
  },
  {
    "name": "autoAlignLayers",
    "aliases": [
      "layer.autoAlign"
    ],
    "required": "at least 2 layers via `targets[]` or current active selection",
    "supportedArgs": "`mode`, `projection`, `targets`, `using`",
    "notes": "`mode/projection` supports `auto`, `perspective`, `cylindrical`, `spherical`, `reposition`.",
    "example": "{\n  \"op\": \"autoAlignLayers\",\n  \"mode\": \"auto\",\n  \"targets\": [\n    {\n      \"layerName\": \"Frame 01\"\n    },\n    {\n      \"layerName\": \"Frame 02\"\n    }\n  ]\n}"
  },
  {
    "name": "autoBlendLayers",
    "aliases": [
      "layer.autoBlend"
    ],
    "required": "at least 2 layers via `targets[]` or current active selection",
    "supportedArgs": "`contentAwareFillTransparentAreas`, `mode`, `seamlessTonesAndColors`, `targets`",
    "notes": "`mode` supports `panorama` and `stackImages`.",
    "example": "{\n  \"op\": \"autoBlendLayers\",\n  \"mode\": \"panorama\",\n  \"seamlessTonesAndColors\": true,\n  \"contentAwareFillTransparentAreas\": true,\n  \"targets\": [\n    {\n      \"layerName\": \"Frame 01\"\n    },\n    {\n      \"layerName\": \"Frame 02\"\n    }\n  ]\n}"
  },
  {
    "name": "translateLayer",
    "aliases": [
      "layer.translate"
    ],
    "required": "`target (or active layer)`, `x/y or horizontal/vertical`",
    "supportedArgs": "`by`, `horizontal`, `vertical`, `x`, `y`",
    "notes": "",
    "example": "{\n  \"op\": \"translateLayer\",\n  \"target\": {\n    \"layerName\": \"Badge\"\n  },\n  \"x\": 12,\n  \"y\": -8\n}"
  },
  {
    "name": "scaleLayer",
    "aliases": [
      "layer.scale"
    ],
    "required": "`target (or active layer)`, `scaleX/scaleY or width/height or scale/percent`",
    "supportedArgs": "`anchor`, `height`, `options`, `percent`, `scale`, `scaleX`, `scaleY`, `width`",
    "notes": "",
    "example": "{\n  \"op\": \"scaleLayer\",\n  \"target\": {\n    \"layerName\": \"Logo\"\n  },\n  \"scaleX\": 120,\n  \"scaleY\": 120\n}"
  },
  {
    "name": "rotateLayer",
    "aliases": [
      "layer.rotate"
    ],
    "required": "`target (or active layer)`, `angle`",
    "supportedArgs": "`anchor`, `angle`, `options`",
    "notes": "",
    "example": "{\n  \"op\": \"rotateLayer\",\n  \"target\": {\n    \"layerName\": \"Badge\"\n  },\n  \"angle\": -12\n}"
  },
  {
    "name": "flipLayer",
    "aliases": [
      "layer.flip"
    ],
    "required": "`target (or active layer)`, `axis`",
    "supportedArgs": "`axis`",
    "notes": "",
    "example": "{\n  \"op\": \"flipLayer\",\n  \"target\": {\n    \"layerName\": \"Hero\"\n  },\n  \"axis\": \"horizontal\"\n}"
  },
  {
    "name": "skewLayer",
    "aliases": [
      "layer.skew"
    ],
    "required": "`target (or active layer)`, `angleH and/or angleV`",
    "supportedArgs": "`angleH`, `angleV`, `horizontal`, `options`, `vertical`",
    "notes": "",
    "example": "{\n  \"op\": \"skewLayer\",\n  \"target\": {\n    \"layerName\": \"Card\"\n  },\n  \"angleH\": 8\n}"
  },
  {
    "name": "placeAsset",
    "aliases": [
      "asset.place"
    ],
    "required": "`input (or path/source)`",
    "supportedArgs": "`artboard`, `at`, `container`, `input`, `linked`, `name`, `normalizePixels`, `parent`, `parentIndex`, `parentLayer`, `parentPlacement`, `path`, `placement`, `source`, `targetParent`, `transformOptions`",
    "notes": "",
    "example": "{\n  \"op\": \"placeAsset\",\n  \"input\": \"https://picsum.photos/seed/hero/1080/1080.jpg\",\n  \"name\": \"Hero Image\"\n}"
  },
  {
    "name": "convertToSmartObject",
    "aliases": [
      "smartObject.convert"
    ],
    "required": "`target (or active layer)`",
    "supportedArgs": "`preserveName`",
    "notes": "",
    "example": "{\n  \"op\": \"convertToSmartObject\",\n  \"target\": {\n    \"layerName\": \"Hero Image\"\n  }\n}"
  },
  {
    "name": "replaceSmartObject",
    "aliases": [
      "smartObject.replace"
    ],
    "required": "`target (or active layer)`, `input (or path/source)`",
    "supportedArgs": "`crop`, `input`, `pageNumber`, `path`, `preserveName`, `source`",
    "notes": "",
    "example": "{\n  \"op\": \"replaceSmartObject\",\n  \"target\": {\n    \"layerName\": \"Hero Image\"\n  },\n  \"input\": \"./assets/new-hero.jpg\"\n}"
  },
  {
    "name": "relinkSmartObject",
    "aliases": [
      "smartObject.relink"
    ],
    "required": "`target (or active layer)`, `input (or path/source)`",
    "supportedArgs": "`input`, `path`, `preserveName`, `source`",
    "notes": "",
    "example": "{\n  \"op\": \"relinkSmartObject\",\n  \"target\": {\n    \"layerName\": \"Hero Image\"\n  },\n  \"input\": \"./assets/linked-hero.psb\"\n}"
  },
  {
    "name": "editSmartObject",
    "aliases": [
      "smartObject.edit"
    ],
    "required": "`target (or active layer)`",
    "supportedArgs": "No op-specific args",
    "notes": "",
    "example": "{\n  \"op\": \"editSmartObject\",\n  \"target\": {\n    \"layerName\": \"Hero Image\"\n  }\n}"
  },
  {
    "name": "selectAll",
    "aliases": [
      "selection.selectAll"
    ],
    "required": "None",
    "supportedArgs": "`docRef`",
    "notes": "",
    "example": "{\n  \"op\": \"selectAll\"\n}"
  },
  {
    "name": "deselect",
    "aliases": [
      "selection.deselect"
    ],
    "required": "None",
    "supportedArgs": "`docRef`",
    "notes": "",
    "example": "{\n  \"op\": \"deselect\"\n}"
  },
  {
    "name": "inverseSelection",
    "aliases": [
      "invertSelection",
      "selection.inverse"
    ],
    "required": "None",
    "supportedArgs": "`docRef`",
    "notes": "",
    "example": "{\n  \"op\": \"inverseSelection\"\n}"
  },
  {
    "name": "featherSelection",
    "aliases": [
      "selection.feather"
    ],
    "required": "`by or radius`",
    "supportedArgs": "`applyEffectAtCanvasBounds`, `by`, `docRef`, `radius`",
    "notes": "",
    "example": "{\n  \"op\": \"featherSelection\",\n  \"radius\": 8\n}"
  },
  {
    "name": "expandSelection",
    "aliases": [
      "selection.expand"
    ],
    "required": "`by`",
    "supportedArgs": "`applyEffectAtCanvasBounds`, `by`, `docRef`",
    "notes": "",
    "example": "{\n  \"op\": \"expandSelection\",\n  \"by\": 12\n}"
  },
  {
    "name": "contractSelection",
    "aliases": [
      "selection.contract"
    ],
    "required": "`by`",
    "supportedArgs": "`applyEffectAtCanvasBounds`, `by`, `docRef`",
    "notes": "",
    "example": "{\n  \"op\": \"contractSelection\",\n  \"by\": 8\n}"
  },
  {
    "name": "growSelection",
    "aliases": [
      "selection.grow"
    ],
    "required": "`by or tolerance`",
    "supportedArgs": "`by`, `docRef`, `tolerance`",
    "notes": "",
    "example": "{\n  \"op\": \"growSelection\",\n  \"tolerance\": 32\n}"
  },
  {
    "name": "smoothSelection",
    "aliases": [
      "selection.smooth"
    ],
    "required": "`radius`",
    "supportedArgs": "`applyEffectAtCanvasBounds`, `docRef`, `radius`",
    "notes": "",
    "example": "{\n  \"op\": \"smoothSelection\",\n  \"radius\": 6\n}"
  },
  {
    "name": "selectSubject",
    "aliases": [
      "selection.subject"
    ],
    "required": "None",
    "supportedArgs": "`allLayers`, `docRef`, `sampleAllLayers`, `target`",
    "notes": "",
    "example": "{\n  \"op\": \"selectSubject\",\n  \"sampleAllLayers\": true\n}"
  },
  {
    "name": "selectColorRange",
    "aliases": [
      "selection.colorRange"
    ],
    "required": "None (or pass `descriptor`)",
    "supportedArgs": "`color`, `descriptor`, `docRef`, `fuzziness`, `invert`, `localizedColorClusters`, `options`, `sampledColor`, `strict`, `target`",
    "notes": "Pass `descriptor` for advanced/host-specific Color Range options. Shorthand mode is best-effort; set `strict: true` to fail when Photoshop rejects shorthand descriptors.",
    "example": "{\n  \"op\": \"selectColorRange\",\n  \"color\": \"#22c55e\",\n  \"fuzziness\": 40\n}"
  },
  {
    "name": "refineSelection",
    "aliases": [
      "selection.refine"
    ],
    "required": "None (or pass `descriptor`)",
    "supportedArgs": "`contrast`, `decontaminateAmount`, `decontaminateColors`, `descriptor`, `docRef`, `feather`, `options`, `output`, `outputTo`, `radius`, `shiftEdge`, `smartRadius`, `smooth`, `strict`, `target`",
    "notes": "Uses Photoshop refine-edge behavior; pass `descriptor` for full host-specific control. Shorthand mode is best-effort; set `strict: true` to fail when Photoshop rejects shorthand descriptors.",
    "example": "{\n  \"op\": \"refineSelection\",\n  \"radius\": 2,\n  \"smooth\": 4,\n  \"feather\": 0.8,\n  \"contrast\": 10,\n  \"shiftEdge\": -5,\n  \"output\": \"selection\"\n}"
  },
  {
    "name": "selectRectangle",
    "aliases": [
      "selection.selectRectangle"
    ],
    "required": "`bounds {left,top,right,bottom}`",
    "supportedArgs": "`antiAlias`, `bounds`, `docRef`, `feather`, `mode`",
    "notes": "",
    "example": "{\n  \"op\": \"selectRectangle\",\n  \"bounds\": {\n    \"left\": 80,\n    \"top\": 80,\n    \"right\": 1000,\n    \"bottom\": 1400\n  },\n  \"mode\": \"replace\"\n}"
  },
  {
    "name": "selectEllipse",
    "aliases": [
      "selection.selectEllipse"
    ],
    "required": "`bounds {left,top,right,bottom}`",
    "supportedArgs": "`antiAlias`, `bounds`, `docRef`, `feather`, `mode`",
    "notes": "",
    "example": "{\n  \"op\": \"selectEllipse\",\n  \"bounds\": {\n    \"left\": 220,\n    \"top\": 260,\n    \"right\": 860,\n    \"bottom\": 900\n  },\n  \"mode\": \"replace\"\n}"
  },
  {
    "name": "selectPolygon",
    "aliases": [
      "selection.selectPolygon"
    ],
    "required": "`points[3+]`",
    "supportedArgs": "`antiAlias`, `docRef`, `feather`, `mode`, `points`",
    "notes": "",
    "example": "{\n  \"op\": \"selectPolygon\",\n  \"points\": [\n    {\n      \"x\": 100,\n      \"y\": 100\n    },\n    {\n      \"x\": 900,\n      \"y\": 120\n    },\n    {\n      \"x\": 560,\n      \"y\": 900\n    }\n  ],\n  \"mode\": \"replace\"\n}"
  },
  {
    "name": "selectLayerPixels",
    "aliases": [
      "selection.loadLayerPixels"
    ],
    "required": "`target (or active layer)`",
    "supportedArgs": "`docRef`, `invert`, `mode`",
    "notes": "",
    "example": "{\n  \"op\": \"selectLayerPixels\",\n  \"target\": {\n    \"layerName\": \"Logo\"\n  },\n  \"mode\": \"replace\"\n}"
  },
  {
    "name": "createChannel",
    "aliases": [
      "channel.create"
    ],
    "required": "None",
    "supportedArgs": "`docRef`, `name`",
    "notes": "",
    "example": "{\n  \"op\": \"createChannel\",\n  \"name\": \"Mask Alpha\"\n}"
  },
  {
    "name": "duplicateChannel",
    "aliases": [
      "channel.duplicate"
    ],
    "required": "`channel/target`",
    "supportedArgs": "`channel`, `channelId`, `channelName`, `docRef`, `name`, `target`",
    "notes": "",
    "example": "{\n  \"op\": \"duplicateChannel\",\n  \"channel\": \"Mask Alpha\",\n  \"name\": \"Mask Alpha Copy\"\n}"
  },
  {
    "name": "deleteChannel",
    "aliases": [
      "channel.delete",
      "channel.remove"
    ],
    "required": "`channel/target`",
    "supportedArgs": "`channel`, `channelId`, `channelName`, `docRef`, `target`",
    "notes": "",
    "example": "{\n  \"op\": \"deleteChannel\",\n  \"channel\": \"Mask Alpha Copy\"\n}"
  },
  {
    "name": "saveSelection",
    "aliases": [
      "selection.save"
    ],
    "required": "None",
    "supportedArgs": "`channel`, `channelId`, `channelName`, `docRef`, `name`, `target`",
    "notes": "",
    "example": "{\n  \"op\": \"saveSelection\",\n  \"name\": \"Saved Selection 1\"\n}"
  },
  {
    "name": "saveSelectionTo",
    "aliases": [
      "selection.saveTo"
    ],
    "required": "None",
    "supportedArgs": "`channel`, `channelId`, `channelName`, `docRef`, `name`, `target`",
    "notes": "",
    "example": "{\n  \"op\": \"saveSelectionTo\",\n  \"channel\": \"Saved Selection 1\"\n}"
  },
  {
    "name": "loadSelection",
    "aliases": [
      "selection.load"
    ],
    "required": "`channel/target`",
    "supportedArgs": "`channel`, `channelId`, `channelName`, `docRef`, `invert`, `mode`, `target`",
    "notes": "",
    "example": "{\n  \"op\": \"loadSelection\",\n  \"channel\": \"Saved Selection 1\"\n}"
  },
  {
    "name": "createPath",
    "aliases": [
      "path.create"
    ],
    "required": "active selection",
    "supportedArgs": "`docRef`, `name`, `tolerance`",
    "notes": "First-class `createPath` builds a work path from the current selection.",
    "example": "{\n  \"op\": \"createPath\",\n  \"name\": \"Subject Path\",\n  \"tolerance\": 2\n}"
  },
  {
    "name": "createPathFromPoints",
    "aliases": [
      "path.createFromPoints"
    ],
    "required": "`points[2+]`",
    "supportedArgs": "`closed`, `docRef`, `name`, `operation`, `points`, `shapeOperation`, `target`",
    "notes": "Each point accepts `{x,y}` (or `anchor:[x,y]`) with optional handles as either `leftDirection/rightDirection` or `backward/forward`, plus optional `smooth`/`kind`. If Photoshop rejects explicit point descriptors in your version, psagent falls back to a polygon-selection work-path conversion (straight segments only).",
    "example": "{\n  \"op\": \"createPathFromPoints\",\n  \"name\": \"Diamond\",\n  \"closed\": true,\n  \"points\": [\n    { \"x\": 540, \"y\": 120 },\n    { \"x\": 920, \"y\": 540 },\n    { \"x\": 540, \"y\": 960 },\n    { \"x\": 160, \"y\": 540 }\n  ]\n}"
  },
  {
    "name": "setPathPoints",
    "aliases": [
      "path.setPoints"
    ],
    "required": "`path/target`, `points[2+]`",
    "supportedArgs": "`closed`, `docRef`, `name`, `operation`, `path`, `pathId`, `pathName`, `points`, `shapeOperation`, `target`",
    "notes": "Point format matches `createPathFromPoints` (`x/y` or `anchor`, optional handle pairs, optional `smooth`/`kind`).",
    "example": "{\n  \"op\": \"setPathPoints\",\n  \"path\": \"Diamond\",\n  \"points\": [\n    { \"x\": 540, \"y\": 160 },\n    { \"x\": 900, \"y\": 540 },\n    { \"x\": 540, \"y\": 920 },\n    { \"x\": 180, \"y\": 540 }\n  ]\n}"
  },
  {
    "name": "deletePath",
    "aliases": [
      "path.delete",
      "path.remove"
    ],
    "required": "`path/target`",
    "supportedArgs": "`docRef`, `path`, `pathId`, `pathName`, `target`",
    "notes": "",
    "example": "{\n  \"op\": \"deletePath\",\n  \"path\": \"Subject Path\"\n}"
  },
  {
    "name": "makeWorkPathFromSelection",
    "aliases": [
      "path.makeWorkPath",
      "selection.makeWorkPath"
    ],
    "required": "active selection",
    "supportedArgs": "`docRef`, `name`, `tolerance`",
    "notes": "",
    "example": "{\n  \"op\": \"makeWorkPathFromSelection\",\n  \"name\": \"Work Path\",\n  \"tolerance\": 2\n}"
  },
  {
    "name": "makeSelectionFromPath",
    "aliases": [
      "path.makeSelection"
    ],
    "required": "`path/target`",
    "supportedArgs": "`antiAlias`, `docRef`, `feather`, `mode`, `path`, `pathId`, `pathName`, `target`",
    "notes": "",
    "example": "{\n  \"op\": \"makeSelectionFromPath\",\n  \"path\": \"Subject Path\",\n  \"mode\": \"replace\"\n}"
  },
  {
    "name": "fillPath",
    "aliases": [
      "path.fill"
    ],
    "required": "`path/target`",
    "supportedArgs": "`antiAlias`, `blendMode`, `color`, `docRef`, `feather`, `fillColor`, `opacity`, `path`, `pathId`, `pathName`, `preserveTransparency`, `target`",
    "notes": "",
    "example": "{\n  \"op\": \"fillPath\",\n  \"path\": \"Subject Path\",\n  \"fillColor\": \"#22c55e\",\n  \"opacity\": 90\n}"
  },
  {
    "name": "strokePath",
    "aliases": [
      "path.stroke"
    ],
    "required": "`path/target`",
    "supportedArgs": "`docRef`, `paintTool`, `path`, `pathId`, `pathName`, `simulatePressure`, `target`, `tool`",
    "notes": "",
    "example": "{\n  \"op\": \"strokePath\",\n  \"path\": \"Subject Path\",\n  \"tool\": \"brush\"\n}"
  },
  {
    "name": "makeClippingPath",
    "aliases": [
      "path.makeClippingPath"
    ],
    "required": "`path/target`",
    "supportedArgs": "`docRef`, `flatness`, `path`, `pathId`, `pathName`, `target`",
    "notes": "",
    "example": "{\n  \"op\": \"makeClippingPath\",\n  \"path\": \"Subject Path\",\n  \"flatness\": 1\n}"
  },
  {
    "name": "addGuide",
    "aliases": [
      "guide.add"
    ],
    "required": "`position/coordinate/value`",
    "supportedArgs": "`direction`, `docRef`, `orientation`, `position`, `coordinate`, `value`",
    "notes": "",
    "example": "{\n  \"op\": \"addGuide\",\n  \"direction\": \"vertical\",\n  \"position\": 540\n}"
  },
  {
    "name": "removeGuide",
    "aliases": [
      "guide.remove",
      "guide.delete"
    ],
    "required": "None",
    "supportedArgs": "`docRef`, `index`",
    "notes": "",
    "example": "{\n  \"op\": \"removeGuide\",\n  \"index\": 0\n}"
  },
  {
    "name": "clearGuides",
    "aliases": [
      "guide.clear",
      "guide.removeAll"
    ],
    "required": "None",
    "supportedArgs": "`docRef`",
    "notes": "",
    "example": "{\n  \"op\": \"clearGuides\"\n}"
  },
  {
    "name": "setSelection",
    "aliases": [
      "selection.set"
    ],
    "required": "shape-dependent coordinates (`rect`/`ellipse`: `x,y,width,height`; `polygon`: `points[3+]`)",
    "supportedArgs": "`shape`, `type`, `x`, `y`, `left`, `top`, `width`, `height`, `points`, `mode`, `feather`, `antiAlias`",
    "notes": "",
    "example": "{\n  \"op\": \"setSelection\",\n  \"shape\": \"rect\",\n  \"x\": 120,\n  \"y\": 120,\n  \"width\": 600,\n  \"height\": 320\n}"
  },
  {
    "name": "modifySelection",
    "aliases": [
      "selection.modify"
    ],
    "required": "`mode` plus mode-specific args (`expand`/`contract`: `by`; `feather`/`smooth`: `radius`; `grow`: `by` or `tolerance`)",
    "supportedArgs": "`mode`, `by`, `radius`, `tolerance`, `applyEffectAtCanvasBounds`",
    "notes": "",
    "example": "{\n  \"op\": \"modifySelection\",\n  \"mode\": \"expand\",\n  \"by\": 10\n}"
  },
  {
    "name": "createLayerMask",
    "aliases": [
      "layerMask.create"
    ],
    "required": "`target (or active layer)`",
    "supportedArgs": "`forceBatchPlay`, `fromSelection`, `hideAll`",
    "notes": "",
    "example": "{\n  \"op\": \"createLayerMask\",\n  \"target\": {\n    \"layerName\": \"Hero\"\n  },\n  \"fromSelection\": true\n}"
  },
  {
    "name": "addLayerMask",
    "aliases": [
      "layerMask.add"
    ],
    "required": "`target (or active layer)`",
    "supportedArgs": "`forceBatchPlay`, `fromSelection`, `hideAll`",
    "notes": "",
    "example": "{\n  \"op\": \"addLayerMask\",\n  \"target\": {\n    \"layerName\": \"Hero\"\n  },\n  \"fromSelection\": true\n}"
  },
  {
    "name": "deleteLayerMask",
    "aliases": [
      "layerMask.delete"
    ],
    "required": "`target (or active layer)`",
    "supportedArgs": "`apply`, `forceBatchPlay`",
    "notes": "",
    "example": "{\n  \"op\": \"deleteLayerMask\",\n  \"target\": {\n    \"layerName\": \"Hero\"\n  },\n  \"apply\": false\n}"
  },
  {
    "name": "removeLayerMask",
    "aliases": [
      "layerMask.remove"
    ],
    "required": "`target (or active layer)`",
    "supportedArgs": "`apply`, `forceBatchPlay`",
    "notes": "",
    "example": "{\n  \"op\": \"removeLayerMask\",\n  \"target\": {\n    \"layerName\": \"Hero\"\n  },\n  \"apply\": false\n}"
  },
  {
    "name": "applyLayerMask",
    "aliases": [
      "layerMask.apply"
    ],
    "required": "`target (or active layer)`",
    "supportedArgs": "No op-specific args",
    "notes": "",
    "example": "{\n  \"op\": \"applyLayerMask\",\n  \"target\": {\n    \"layerName\": \"Hero\"\n  }\n}"
  },
  {
    "name": "createClippingMask",
    "aliases": [
      "layerMask.clip"
    ],
    "required": "`target (or active layer)`",
    "supportedArgs": "No op-specific args",
    "notes": "",
    "example": "{\n  \"op\": \"createClippingMask\",\n  \"target\": {\n    \"layerName\": \"Placed Photo\"\n  }\n}"
  },
  {
    "name": "releaseClippingMask",
    "aliases": [
      "layerMask.unclip"
    ],
    "required": "`target (or active layer)`",
    "supportedArgs": "No op-specific args",
    "notes": "",
    "example": "{\n  \"op\": \"releaseClippingMask\",\n  \"target\": {\n    \"layerName\": \"Placed Photo\"\n  }\n}"
  },
  {
    "name": "createVectorMask",
    "aliases": [
      "vectorMask.create",
      "layerMask.vectorCreate"
    ],
    "required": "`target (or active layer)`",
    "supportedArgs": "`path`, `pathId`, `pathName`, `target`",
    "notes": "Pass `path/pathName/pathId`, or ensure an existing Work Path is present. The bridge preflights path existence and returns actionable errors before applying.",
    "example": "{\n  \"op\": \"createVectorMask\",\n  \"target\": {\n    \"layerName\": \"Placed Photo\"\n  },\n  \"path\": \"Subject Path\"\n}"
  },
  {
    "name": "deleteVectorMask",
    "aliases": [
      "vectorMask.delete",
      "layerMask.vectorDelete"
    ],
    "required": "`target (or active layer)`",
    "supportedArgs": "No op-specific args",
    "notes": "",
    "example": "{\n  \"op\": \"deleteVectorMask\",\n  \"target\": {\n    \"layerName\": \"Placed Photo\"\n  }\n}"
  },
  {
    "name": "createAdjustmentLayer",
    "aliases": [
      "adjustment.create"
    ],
    "required": "None (`levels` default when omitted)",
    "supportedArgs": "`adjustment`, `artboard`, `at`, `container`, `kind`, `name`, `parent`, `parentIndex`, `parentLayer`, `parentPlacement`, `placement`, `settings`, `targetParent`, `type`, plus adjustment fields",
    "notes": "Pass either (a) `type`/`kind` + settings fields, (b) `adjustment` as a plain object (`{ \"brightness\": 10, ... }`), or (c) `adjustment` as a raw descriptor with `_obj`.",
    "example": "{\n  \"op\": \"createAdjustmentLayer\",\n  \"type\": \"brightnessContrast\",\n  \"adjustment\": {\n    \"brightness\": 8,\n    \"contrast\": 12\n  },\n  \"name\": \"Grade\"\n}"
  },
  {
    "name": "setAdjustmentLayer",
    "aliases": [
      "adjustment.set"
    ],
    "required": "`target (or active layer)` and adjustment descriptor or kind/settings",
    "supportedArgs": "`adjustment`, `kind`, `settings`, `target`, `type`, plus adjustment fields",
    "notes": "",
    "example": "{\n  \"op\": \"setAdjustmentLayer\",\n  \"target\": {\n    \"layerName\": \"Grade\"\n  },\n  \"type\": \"hueSaturation\",\n  \"adjustment\": {\n    \"masterHue\": 8,\n    \"masterSaturation\": -10,\n    \"masterLightness\": 4\n  }\n}"
  },
  {
    "name": "applyFilter",
    "aliases": [
      "filter.apply"
    ],
    "required": "`filter (or kind)`",
    "supportedArgs": "`filter`, `kind`",
    "notes": "",
    "example": "{\n  \"op\": \"applyFilter\",\n  \"target\": {\n    \"layerName\": \"Hero\"\n  },\n  \"filter\": \"gaussianBlur\",\n  \"radius\": 4\n}"
  },
  {
    "name": "applyGaussianBlur",
    "aliases": [
      "filter.gaussianBlur"
    ],
    "required": "`target (or active layer)`, `radius`",
    "supportedArgs": "`radius`",
    "notes": "",
    "example": "{\n  \"op\": \"applyGaussianBlur\",\n  \"target\": {\n    \"layerName\": \"Hero\"\n  },\n  \"radius\": 3\n}"
  },
  {
    "name": "applyAddNoise",
    "aliases": [
      "filter.addNoise",
      "applyNoise",
      "filter.noise"
    ],
    "required": "`target (or active layer)`, `amount`",
    "supportedArgs": "`amount`, `distribution`, `monochromatic`",
    "notes": "",
    "example": "{\n  \"op\": \"applyAddNoise\",\n  \"target\": {\n    \"layerName\": \"Texture\"\n  },\n  \"amount\": 8,\n  \"distribution\": \"uniform\",\n  \"monochromatic\": true\n}"
  },
  {
    "name": "applyUnsharpMask",
    "aliases": [
      "filter.unsharpMask"
    ],
    "required": "`target (or active layer)`, `amount, radius, threshold`",
    "supportedArgs": "`amount`, `radius`, `threshold`",
    "notes": "",
    "example": "{\n  \"op\": \"applyUnsharpMask\",\n  \"target\": {\n    \"layerName\": \"Hero\"\n  },\n  \"amount\": 80,\n  \"radius\": 1.5,\n  \"threshold\": 2\n}"
  },
  {
    "name": "applySharpen",
    "aliases": [
      "filter.sharpen"
    ],
    "required": "`target (or active layer)`",
    "supportedArgs": "No op-specific args",
    "notes": "",
    "example": "{\n  \"op\": \"applySharpen\",\n  \"target\": {\n    \"layerName\": \"Hero\"\n  }\n}"
  },
  {
    "name": "applyBlur",
    "aliases": [
      "filter.blur"
    ],
    "required": "`target (or active layer)`",
    "supportedArgs": "No op-specific args",
    "notes": "",
    "example": "{\n  \"op\": \"applyBlur\",\n  \"target\": {\n    \"layerName\": \"Hero\"\n  }\n}"
  },
  {
    "name": "applyMotionBlur",
    "aliases": [
      "filter.motionBlur"
    ],
    "required": "`target (or active layer)`, `angle`, `radius`",
    "supportedArgs": "`angle`, `radius`",
    "notes": "",
    "example": "{\n  \"op\": \"applyMotionBlur\",\n  \"target\": {\n    \"layerName\": \"Hero\"\n  },\n  \"angle\": 18,\n  \"radius\": 24\n}"
  },
  {
    "name": "applySmartBlur",
    "aliases": [
      "filter.smartBlur"
    ],
    "required": "`target (or active layer)`, `radius`, `threshold`",
    "supportedArgs": "`mode`, `quality`, `radius`, `threshold`",
    "notes": "",
    "example": "{\n  \"op\": \"applySmartBlur\",\n  \"target\": {\n    \"layerName\": \"Hero\"\n  },\n  \"radius\": 3,\n  \"threshold\": 12,\n  \"quality\": \"high\",\n  \"mode\": \"normal\"\n}"
  },
  {
    "name": "applyHighPass",
    "aliases": [
      "filter.highPass"
    ],
    "required": "`target (or active layer)`, `radius`",
    "supportedArgs": "`radius`",
    "notes": "",
    "example": "{\n  \"op\": \"applyHighPass\",\n  \"target\": {\n    \"layerName\": \"Hero\"\n  },\n  \"radius\": 2\n}"
  },
  {
    "name": "applyMedianNoise",
    "aliases": [
      "filter.median"
    ],
    "required": "`target (or active layer)`, `radius`",
    "supportedArgs": "`radius`",
    "notes": "",
    "example": "{\n  \"op\": \"applyMedianNoise\",\n  \"target\": {\n    \"layerName\": \"Texture\"\n  },\n  \"radius\": 3\n}"
  },
  {
    "name": "applyMinimum",
    "aliases": [
      "filter.minimum"
    ],
    "required": "`target (or active layer)`, `radius`",
    "supportedArgs": "`radius`",
    "notes": "",
    "example": "{\n  \"op\": \"applyMinimum\",\n  \"target\": {\n    \"layerName\": \"Mask\"\n  },\n  \"radius\": 1\n}"
  },
  {
    "name": "applyMaximum",
    "aliases": [
      "filter.maximum"
    ],
    "required": "`target (or active layer)`, `radius`",
    "supportedArgs": "`radius`",
    "notes": "",
    "example": "{\n  \"op\": \"applyMaximum\",\n  \"target\": {\n    \"layerName\": \"Mask\"\n  },\n  \"radius\": 1\n}"
  },
  {
    "name": "applyDustAndScratches",
    "aliases": [
      "filter.dustAndScratches"
    ],
    "required": "`target (or active layer)`, `radius`, `threshold`",
    "supportedArgs": "`radius`, `threshold`",
    "notes": "",
    "example": "{\n  \"op\": \"applyDustAndScratches\",\n  \"target\": {\n    \"layerName\": \"Texture\"\n  },\n  \"radius\": 2,\n  \"threshold\": 4\n}"
  },
  {
    "name": "contentAwareFill",
    "aliases": [
      "contentAware.fill"
    ],
    "required": "active selection (or pass `descriptor` with custom behavior)",
    "supportedArgs": "`colorAdaptation`, `descriptor`, `docRef`, `mirror`, `options`, `rotationAdaptation`, `scale`, `target`",
    "notes": "",
    "example": "{\n  \"op\": \"contentAwareFill\",\n  \"colorAdaptation\": true,\n  \"rotationAdaptation\": false\n}"
  },
  {
    "name": "contentAwareScale",
    "aliases": [
      "contentAware.scale"
    ],
    "required": "`target (or active layer)`",
    "supportedArgs": "`allowMaskedLayer`, `descriptor`, `height`, `options`, `scale`, `scaleX`, `scaleY`, `target`, `width`",
    "notes": "By default, masked targets are blocked up front because Photoshop frequently rejects Content-Aware Scale on masked layers. Set `allowMaskedLayer: true` for best-effort attempts.",
    "example": "{\n  \"op\": \"contentAwareScale\",\n  \"target\": {\n    \"layerName\": \"Hero\"\n  },\n  \"scaleX\": 95,\n  \"scaleY\": 95\n}"
  },
  {
    "name": "contentAwareMove",
    "aliases": [
      "contentAware.move"
    ],
    "required": "`target (or active layer)`",
    "supportedArgs": "`adaptation`, `color`, `descriptor`, `dx`, `dy`, `horizontal`, `options`, `structure`, `target`, `vertical`, `x`, `y`",
    "notes": "",
    "example": "{\n  \"op\": \"contentAwareMove\",\n  \"target\": {\n    \"layerName\": \"Hero\"\n  },\n  \"x\": 24,\n  \"y\": -12,\n  \"adaptation\": \"veryStrict\"\n}"
  },
  {
    "name": "createTextLayer",
    "aliases": [
      "text.create"
    ],
    "required": "`text (or contents)`",
    "supportedArgs": "`alignment`, `align`, `artboard`, `at`, `avoidOverlapWith`, `color`, `container`, `contents`, `docRef`, `ellipsis`, `font`, `fontName`, `fontSize`, `hardMinFontSize`, `justification`, `maxHeight`, `maxWidth`, `minFontSize`, `name`, `overflow`, `overflowMode`, `overlapGap`, `parent`, `parentIndex`, `parentLayer`, `parentPlacement`, `placement`, `position`, `targetParent`, `text`, `textColor`",
    "notes": "`position.y` is the text baseline, not the top of glyph bounds. For large display text, place the baseline lower than the desired visual top. `createTextLayer` already accepts style/fitting args; use `setTextStyle` for post-create updates.",
    "example": "{\n  \"op\": \"createTextLayer\",\n  \"name\": \"Headline\",\n  \"text\": \"Summer Launch\",\n  \"fontSize\": 72,\n  \"textColor\": \"#ffffff\",\n  \"alignment\": \"center\",\n  \"position\": {\n    \"x\": 0,\n    \"y\": 220\n  },\n  \"maxWidth\": 1080\n}"
  },
  {
    "name": "setText",
    "aliases": [
      "text.set"
    ],
    "required": "`target (or active layer)`, `text (or contents)`",
    "supportedArgs": "`contents`, `text`",
    "notes": "",
    "example": "{\n  \"op\": \"setText\",\n  \"target\": {\n    \"layerName\": \"Headline\"\n  },\n  \"text\": \"New headline copy\"\n}"
  },
  {
    "name": "setTextStyle",
    "aliases": [
      "text.style"
    ],
    "required": "`target (or active layer)`, `at least one style/content field`",
    "supportedArgs": "`alignment`, `align`, `avoidOverlapWith`, `color`, `contents`, `ellipsis`, `font`, `fontName`, `fontSize`, `hardMinFontSize`, `justification`, `maxHeight`, `maxWidth`, `minFontSize`, `overflow`, `overflowMode`, `overlapGap`, `position`, `text`, `textColor`",
    "notes": "",
    "example": "{\n  \"op\": \"setTextStyle\",\n  \"target\": {\n    \"layerName\": \"Headline\"\n  },\n  \"font\": \"Avenir Next\",\n  \"textColor\": \"#f8fafc\",\n  \"alignment\": \"center\",\n  \"fontSize\": 64,\n  \"maxWidth\": 860,\n  \"overflow\": \"resize\"\n}"
  },
  {
    "name": "setTextWarp",
    "aliases": [
      "text.warp"
    ],
    "required": "`target (or active layer)` and at least one warp field",
    "supportedArgs": "`bend`, `horizontalDistortion`, `orientation`, `style`, `target`, `verticalDistortion`, `warpPerspective`, `warpPerspectiveOther`, `warpStyle`, `warpValue`",
    "notes": "",
    "example": "{\n  \"op\": \"setTextWarp\",\n  \"target\": {\n    \"layerName\": \"Headline\"\n  },\n  \"style\": \"arc\",\n  \"bend\": 24,\n  \"horizontalDistortion\": 0,\n  \"verticalDistortion\": 0\n}"
  },
  {
    "name": "setTextOnPath",
    "aliases": [
      "text.onPath"
    ],
    "required": "`target (or active layer)` and `path/pathName/pathId` (or `commands[]/command/descriptor`)",
    "supportedArgs": "`command`, `commands`, `descriptor`, `options`, `orientation`, `path`, `pathId`, `pathName`, `strict`, `target`, `targetPath`",
    "notes": "Photoshop text-on-path descriptors vary by host build. The shorthand payload is best-effort; pass explicit `commands`/`descriptor` for deterministic behavior. Set `strict: true` to fail when shorthand application is rejected.",
    "example": "{\n  \"op\": \"setTextOnPath\",\n  \"target\": {\n    \"layerName\": \"Headline\"\n  },\n  \"path\": \"Subject Path\",\n  \"orientation\": \"horizontal\"\n}"
  },
  {
    "name": "createShapeLayer",
    "aliases": [
      "shape.create"
    ],
    "required": "`bounds or x/y/width/height`",
    "supportedArgs": "`artboard`, `at`, `bounds`, `color`, `container`, `cornerRadius`, `fill`, `fillType`, `gradient`, `gradientAngle`, `gradientFrom`, `gradientScale`, `gradientTo`, `gradientType`, `height`, `name`, `parent`, `parentIndex`, `parentLayer`, `parentPlacement`, `placement`, `radius`, `shape`, `shapeType`, `targetParent`, `width`, `x`, `y`",
    "notes": "",
    "example": "{\n  \"op\": \"createShapeLayer\",\n  \"name\": \"CTA Button\",\n  \"shape\": \"rectangle\",\n  \"x\": 88,\n  \"y\": 980,\n  \"width\": 320,\n  \"height\": 92,\n  \"fillType\": \"gradient\",\n  \"cornerRadius\": 46,\n  \"gradient\": {\n    \"from\": \"#22c55e\",\n    \"to\": \"#15803d\",\n    \"angle\": 90\n  }\n}"
  },
  {
    "name": "export",
    "aliases": [
      "document.export",
      "render"
    ],
    "required": "`output`",
    "supportedArgs": "`docRef`, `target`, `output`, `format`, `quality`, `metadata`, `sRGB`, `options`",
    "notes": "",
    "example": "{\n  \"op\": \"export\",\n  \"output\": \"./tmp/frame.png\",\n  \"format\": \"png\",\n  \"quality\": 90\n}"
  },
  {
    "name": "exportDocument",
    "aliases": [
      "document.exportDocument"
    ],
    "required": "`output`",
    "supportedArgs": "`docRef`, `output`, `format`, `quality`, `metadata`, `sRGB`, `options`",
    "notes": "",
    "example": "{\n  \"op\": \"exportDocument\",\n  \"output\": \"./tmp/document.png\",\n  \"format\": \"png\"\n}"
  },
  {
    "name": "exportLayer",
    "aliases": [
      "document.exportLayer"
    ],
    "required": "`target (or active layer)`, `output`",
    "supportedArgs": "`target`, `docRef`, `output`, `format`, `quality`, `metadata`, `sRGB`, `options`",
    "notes": "",
    "example": "{\n  \"op\": \"exportLayer\",\n  \"target\": {\n    \"layerName\": \"Hero\"\n  },\n  \"output\": \"./tmp/hero.png\",\n  \"format\": \"png\"\n}"
  },
  {
    "name": "exportLayersByName",
    "aliases": [
      "document.exportLayersByName"
    ],
    "required": "`match`, `outputDir (or output)`",
    "supportedArgs": "`docRef`, `format`, `match`, `output`, `outputDir`",
    "notes": "",
    "example": "{\n  \"op\": \"exportLayersByName\",\n  \"match\": \"^(Hero|CTA)$\",\n  \"format\": \"png\",\n  \"outputDir\": \"./tmp/layers\"\n}"
  },
  {
    "name": "exportArtboards",
    "aliases": [
      "artboard.export"
    ],
    "required": "`outputDir` (or `commands[]/command/descriptor`)",
    "supportedArgs": "`command`, `commands`, `descriptor`, `format`, `options`, `outputDir`",
    "notes": "Default behavior exports each artboard to `outputDir` using per-artboard crop bounds. For host-specific behavior, pass explicit `descriptor`/`commands`.",
    "example": "{\n  \"op\": \"exportArtboards\",\n  \"outputDir\": \"./tmp/artboards\",\n  \"format\": \"png\"\n}"
  },
  {
    "name": "getPixels",
    "aliases": [
      "imaging.getPixels"
    ],
    "required": "None",
    "supportedArgs": "`componentSize`, `colorSpace`, `docRef`, `includeData`, `options`, `sourceBounds`, `target`, `targetBounds`, `targetSize`",
    "notes": "",
    "example": "{\n  \"op\": \"getPixels\",\n  \"target\": {\n    \"layerName\": \"Hero\"\n  },\n  \"sourceBounds\": {\n    \"left\": 0,\n    \"top\": 0,\n    \"right\": 512,\n    \"bottom\": 512\n  },\n  \"includeData\": false\n}"
  },
  {
    "name": "putPixels",
    "aliases": [
      "imaging.putPixels"
    ],
    "required": "`imageData/pixels`",
    "supportedArgs": "`componentSize`, `colorSpace`, `docRef`, `imageData`, `options`, `pixels`, `target`, `targetBounds`",
    "notes": "",
    "example": "{\n  \"op\": \"putPixels\",\n  \"target\": {\n    \"layerName\": \"Hero\"\n  },\n  \"imageData\": {\n    \"width\": 64,\n    \"height\": 64,\n    \"components\": 4,\n    \"componentSize\": 8,\n    \"colorSpace\": \"RGB\",\n    \"data\": \"BASE64_ENCODED_BYTES\"\n  }\n}"
  },
  {
    "name": "getSelectionPixels",
    "aliases": [
      "imaging.getSelection"
    ],
    "required": "None",
    "supportedArgs": "`componentSize`, `colorSpace`, `docRef`, `includeData`, `options`, `sourceBounds`, `targetBounds`, `targetSize`",
    "notes": "",
    "example": "{\n  \"op\": \"getSelectionPixels\",\n  \"includeData\": false\n}"
  },
  {
    "name": "putSelectionPixels",
    "aliases": [
      "imaging.putSelection"
    ],
    "required": "`imageData/pixels`",
    "supportedArgs": "`componentSize`, `colorSpace`, `docRef`, `imageData`, `options`, `pixels`, `targetBounds`",
    "notes": "",
    "example": "{\n  \"op\": \"putSelectionPixels\",\n  \"imageData\": {\n    \"width\": 64,\n    \"height\": 64,\n    \"components\": 1,\n    \"componentSize\": 8,\n    \"colorSpace\": \"Grayscale\",\n    \"data\": \"BASE64_ENCODED_BYTES\"\n  }\n}"
  },
  {
    "name": "getLayerMaskPixels",
    "aliases": [
      "imaging.getLayerMask"
    ],
    "required": "`target (or active layer)`",
    "supportedArgs": "`componentSize`, `colorSpace`, `docRef`, `includeData`, `options`, `sourceBounds`, `target`, `targetBounds`, `targetSize`",
    "notes": "",
    "example": "{\n  \"op\": \"getLayerMaskPixels\",\n  \"target\": {\n    \"layerName\": \"Hero\"\n  },\n  \"includeData\": false\n}"
  },
  {
    "name": "putLayerMaskPixels",
    "aliases": [
      "imaging.putLayerMask"
    ],
    "required": "`target (or active layer)`, `imageData/pixels`",
    "supportedArgs": "`componentSize`, `colorSpace`, `docRef`, `imageData`, `options`, `pixels`, `target`, `targetBounds`",
    "notes": "",
    "example": "{\n  \"op\": \"putLayerMaskPixels\",\n  \"target\": {\n    \"layerName\": \"Hero\"\n  },\n  \"imageData\": {\n    \"width\": 64,\n    \"height\": 64,\n    \"components\": 1,\n    \"componentSize\": 8,\n    \"colorSpace\": \"Grayscale\",\n    \"data\": \"BASE64_ENCODED_BYTES\"\n  }\n}"
  },
  {
    "name": "encodeImageData",
    "aliases": [
      "imaging.encodeImageData"
    ],
    "required": "`imageData/pixels`",
    "supportedArgs": "`format`, `imageData`, `options`, `pixels`, `quality`",
    "notes": "",
    "example": "{\n  \"op\": \"encodeImageData\",\n  \"format\": \"png\",\n  \"imageData\": {\n    \"width\": 64,\n    \"height\": 64,\n    \"components\": 4,\n    \"componentSize\": 8,\n    \"colorSpace\": \"RGB\",\n    \"data\": \"BASE64_ENCODED_BYTES\"\n  }\n}"
  },
  {
    "name": "playAction",
    "aliases": [
      "action.play"
    ],
    "required": "`action/name` and `actionSet/set`",
    "supportedArgs": "`action`, `actionSet`, `name`, `set`, `setName`",
    "notes": "",
    "example": "{\n  \"op\": \"playAction\",\n  \"actionSet\": \"My Set\",\n  \"action\": \"Warm Grade\"\n}"
  },
  {
    "name": "playActionSet",
    "aliases": [
      "actionSet.play"
    ],
    "required": "`actionSet/set/name`",
    "supportedArgs": "`action`, `actionSet`, `name`, `set`, `setName`",
    "notes": "",
    "example": "{\n  \"op\": \"playActionSet\",\n  \"actionSet\": \"My Set\"\n}"
  },
  {
    "name": "batchPlay",
    "aliases": [
      "action.batchPlay"
    ],
    "required": "`commands[] or command/descriptor`",
    "supportedArgs": "`allowUnavailable`, `command`, `commands`, `descriptor`, `options`",
    "notes": "`textStyleRange[*].textStyle` replaces style objects rather than patching them. Include every style field you need to preserve (font family/style, size, color, etc.), or use first-class text ops (`createTextLayer` / `setTextStyle`) when possible.",
    "example": "{\n  \"op\": \"batchPlay\",\n  \"commands\": [\n    {\n      \"_obj\": \"set\",\n      \"_target\": [\n        {\n          \"_ref\": \"textLayer\",\n          \"_name\": \"Headline\"\n        }\n      ],\n      \"to\": {\n        \"_obj\": \"textLayer\",\n        \"textStyleRange\": [\n          {\n            \"_obj\": \"textStyleRange\",\n            \"from\": 0,\n            \"to\": 8,\n            \"textStyle\": {\n              \"_obj\": \"textStyle\",\n              \"fontPostScriptName\": \"Impact\",\n              \"fontName\": \"Impact\",\n              \"fontStyleName\": \"Regular\",\n              \"size\": {\n                \"_obj\": \"unitDouble\",\n                \"_unit\": \"pointsUnit\",\n                \"_value\": 200\n              },\n              \"color\": {\n                \"_obj\": \"RGBColor\",\n                \"red\": 255,\n                \"green\": 255,\n                \"blue\": 255\n              }\n            }\n          }\n        ]\n      }\n    }\n  ]\n}"
  }
] as const;
